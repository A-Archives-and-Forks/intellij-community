// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.package com.intellij.platform.searchEverywhere.frontendimport com.intellij.ide.actions.SearchEverywhereManagerFactoryimport com.intellij.ide.actions.searcheverywhere.SearchEverywhereManagerimport com.intellij.ide.actions.searcheverywhere.SearchEverywherePopupInstanceimport com.intellij.ide.actions.searcheverywhere.SearchEverywhereUIimport com.intellij.openapi.actionSystem.AnActionEventimport com.intellij.openapi.actionSystem.DataContextimport com.intellij.openapi.application.ApplicationManagerimport com.intellij.openapi.application.EDTimport com.intellij.openapi.components.Serviceimport com.intellij.openapi.project.DumbAwareActionimport com.intellij.openapi.project.Projectimport com.intellij.openapi.ui.popup.JBPopupimport com.intellij.openapi.ui.popup.JBPopupFactoryimport com.intellij.openapi.util.Disposerimport com.intellij.openapi.util.registry.Registryimport com.intellij.platform.searchEverywhere.SeSessionEntityimport com.intellij.platform.searchEverywhere.frontend.ui.SePopupContentPaneimport com.intellij.platform.searchEverywhere.frontend.vm.SePopupVmimport com.intellij.platform.searchEverywhere.providers.SeLogimport com.intellij.platform.util.coroutines.childScopeimport com.intellij.platform.util.coroutines.sync.OverflowSemaphoreimport com.intellij.ui.SearchTextFieldimport com.intellij.util.SystemPropertiesimport com.intellij.util.containers.ContainerUtilimport com.intellij.util.ui.StartupUiUtilimport fleet.kernel.changeimport fleet.kernel.sharedimport kotlinx.coroutines.*import kotlinx.coroutines.channels.BufferOverflowimport org.jetbrains.annotations.ApiStatus@ApiStatus.Internal@Service(Service.Level.PROJECT)class SeFrontendService(val project: Project, private val coroutineScope: CoroutineScope) : SearchEverywhereManager {  private val popupSemaphore = OverflowSemaphore(1, overflow = BufferOverflow.DROP_LATEST)  @Volatile  private var popupInstance: SePopupInstance? = null  @Volatile  private var historyIterator: HistoryIterator? = null  private val historyList = SearchHistoryList()  override fun show(tabId: String, searchText: String?, initEvent: AnActionEvent) {    coroutineScope.launch {      doShowPopup(tabId, searchText, initEvent.dataContext)    }  }  private suspend fun doShowPopup(tabId: String, searchText: String?, dataContext: DataContext) {    val popupScope = coroutineScope.childScope("SearchEverywhereFrontendService popup scope")    val sessionRef = SeSessionEntity.createRef()    // Replace empty searchText by the last one in the search history    var searchTextToShow = searchText    historyIterator = historyList.getIterator(tabId)    //history could be suppressed by user for some reasons (creating promo video, conference demo etc.)    var suppressHistory = SystemProperties.getBooleanProperty("idea.searchEverywhere.noHistory", false)    //or could be suppressed just for All tab in registry    suppressHistory = suppressHistory ||                      (ALL_CONTRIBUTORS_GROUP_ID == tabId &&                       Registry.`is`("search.everywhere.disable.history.for.all"))    if (searchText == null && !suppressHistory) {      searchTextToShow = historyIterator?.prev()    }    try {      popupSemaphore.withPermit {        val startTime = System.currentTimeMillis()        val tabs = SeTabFactory.EP_NAME.extensionList.map {          it.getTab(project, sessionRef, dataContext)        }        var popup: JBPopup? = null        val popupVm = SePopupVm(popupScope, project, sessionRef, tabs, searchTextToShow) {          popup?.cancel()          popup = null        }        popupVm.showTab(tabId)        val completable = CompletableDeferred<Unit>()        withContext(Dispatchers.EDT) {          val contentPane = SePopupContentPane(project, popupVm)          popup = createPopup(contentPane, project) {            completable.complete(Unit)          }          popup?.showCenteredInCurrentWindow(project)          popupInstance = SePopupInstance(popupVm, contentPane)          val endTime = System.currentTimeMillis()          SeLog.log { "Search Everywhere popup opened in ${endTime - startTime} ms" }          DumbAwareAction.create { showHistoryItem(true) }            .registerCustomShortcutSet(SearchTextField.SHOW_HISTORY_SHORTCUT, contentPane)          DumbAwareAction.create { showHistoryItem(false) }            .registerCustomShortcutSet(SearchTextField.ALT_SHOW_HISTORY_SHORTCUT, contentPane)        }        completable.await()      }    }    finally {      popupInstance = null      withContext(NonCancellable) {        popupScope.cancel()        change {          shared {            sessionRef.derefOrNull()?.delete()          }        }      }    }  }  private fun createPopup(panel: SePopupContentPane, project: Project, onCancel: () -> Unit): JBPopup {    val popup = JBPopupFactory.getInstance().createComponentPopupBuilder(panel, panel.preferableFocusedComponent)      .setProject(project)      .setModalContext(false)      .setNormalWindowLevel(StartupUiUtil.isWaylandToolkit())      .setCancelOnClickOutside(true)      .setRequestFocus(true)      .setCancelKeyEnabled(false)      .setResizable(true)      .setMovable(true)      .setDimensionServiceKey(project, POPUP_LOCATION_SETTINGS_KEY, true)      .setLocateWithinScreenBounds(false)      .setCancelCallback {        saveSearchText()        onCancel(); true      }      .createPopup()    Disposer.register(popup, panel)    return popup  }  override fun isShown(): Boolean = popupInstance != null  @Deprecated("Deprecated in the interface")  override fun getCurrentlyShownUI(): SearchEverywhereUI {    throw UnsupportedOperationException("The method is deprecated. Please use getCurrentlyShownPopupInstance() instead.")  }  override fun getCurrentlyShownPopupInstance(): SearchEverywherePopupInstance? = popupInstance  override fun getSelectedTabID(): String = popupInstance?.getSelectedTabID() ?: ""  override fun setSelectedTabID(tabID: String) {    popupInstance?.setSelectedTabID(tabID)  }  override fun toggleEverywhereFilter() {    popupInstance?.toggleEverywhereFilter()  }  override fun isEverywhere(): Boolean = popupInstance?.isEverywhere() ?: false  companion object {    @JvmStatic    fun getInstance(project: Project): SeFrontendService = project.getService(SeFrontendService::class.java)    @JvmStatic    val isEnabled: Boolean      get() = Registry.`is`("search.everywhere.new.enabled", false)    @JvmStatic    fun isExtendedInfoEnabled(): Boolean {      return Registry.`is`("search.everywhere.footer.extended.info") || ApplicationManager.getApplication().isInternal()    }    private const val POPUP_LOCATION_SETTINGS_KEY: String = "search.everywhere.popup"    private const val ALL_CONTRIBUTORS_GROUP_ID = "SearchEverywhereContributor.All"  }  private fun saveSearchText() {    if (!isShown()) {      return    }    updateHistoryIterator()    val searchText = popupInstance?.getSearchText()    val selectedTabID = popupInstance?.getSelectedTabID()    if (searchText != null && searchText.isNotEmpty() && selectedTabID != null) {      historyList.saveText(searchText, selectedTabID)    }  }  private fun showHistoryItem(next: Boolean) {    if (!isShown()) {      return    }    updateHistoryIterator()    val searchText = if (next) historyIterator?.next() else historyIterator?.prev()    searchText?.let { popupInstance?.setSearchText(it) }    popupInstance?.selectAllInSearchText()  }  fun getHistoryItems(): List<String> {    if (!isShown()) return ContainerUtil.emptyList()    updateHistoryIterator()    return historyIterator?.getList() ?: emptyList()  }  private fun updateHistoryIterator() {    if (!isShown()) {      return    }    val selectedContributorID = popupInstance?.getSelectedTabID()    if (selectedContributorID != null && historyIterator?.getContributorID() != selectedContributorID) {      historyIterator = historyList.getIterator(selectedContributorID)    }  }  private class SearchHistoryList {    companion object {      private const val HISTORY_LIMIT = 50    }    private data class HistoryItem(val searchText: String, val contributorID: String)    private val historyList = mutableListOf<HistoryItem>()    fun getIterator(contributorID: String): HistoryIterator {      val list = getHistoryForContributor(contributorID)      return HistoryIterator(contributorID, list)    }    fun saveText(text: String, contributorID: String) {      historyList.find { it.searchText == text && it.contributorID == contributorID }?.let {        historyList.remove(it)      }      historyList.add(HistoryItem(text, contributorID))      val list = filteredHistory { it.contributorID == contributorID }      if (list.size > HISTORY_LIMIT) {        historyList.find { it.contributorID == contributorID }?.let {          historyList.remove(it)        }      }    }    private fun getHistoryForContributor(contributorID: String): List<String> {      return if (contributorID == ALL_CONTRIBUTORS_GROUP_ID) {        val entireHistory = filteredHistory { true }        val size = entireHistory.size        if (size > HISTORY_LIMIT) entireHistory.subList(size - HISTORY_LIMIT, size) else entireHistory      }      else {        filteredHistory { it.contributorID == contributorID }      }    }    private fun filteredHistory(predicate: (HistoryItem) -> Boolean): List<String> {      return historyList        .filter(predicate)        .map { it.searchText }        .distinct()    }  }  private class HistoryIterator(    private val contributorID: String,    private val list: List<String>,  ) {    private var index = -1    fun getContributorID(): String {      return contributorID    }    fun getList(): List<String> {      return list    }    fun next(): String {      if (list.isEmpty()) {        return ""      }      index += 1      if (index >= list.size) {        index = 0      }      return list[index]    }    fun prev(): String {      if (list.isEmpty()) {        return ""      }      index -= 1      if (index < 0) {        index = list.size - 1      }      return list[index]    }  }}@ApiStatus.Internalclass RemDevFriendlySearchEverywhereManager : SearchEverywhereManagerFactory {  override fun isAvailable(): Boolean = SeFrontendService.isEnabled  override fun getManager(project: Project): SearchEverywhereManager = SeFrontendService.getInstance(project)}