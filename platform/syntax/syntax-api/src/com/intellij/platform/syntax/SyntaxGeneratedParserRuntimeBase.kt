// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
@file:Suppress("FunctionName")

package com.intellij.platform.syntax.util

import com.intellij.openapi.util.text.StringHash
import com.intellij.platform.syntax.SyntaxElementType
import com.intellij.platform.syntax.element.SyntaxTokenTypes
import com.intellij.platform.syntax.lexer.Lexer
import com.intellij.platform.syntax.parser.SyntaxTreeBuilder
import com.intellij.platform.syntax.parser.WhitespacesAndCommentsBinder
import com.intellij.platform.syntax.parser.WhitespacesBinders
import com.intellij.platform.syntax.util.SyntaxGeneratedParserRuntimeBase.*
import org.jetbrains.annotations.Contract
import org.jetbrains.annotations.NonNls

import kotlin.math.min


/**
 * This class is a runtime engine for parsers generated by [Grammar-Kit](https://github.com/JetBrains/Grammar-Kit).
 * <br></br>
 * Here is the original [
 * GeneratedParserUtilBase](https://github.com/JetBrains/Grammar-Kit/blob/master/support/org/intellij/grammar/parser/GeneratedParserUtilBase.java) code.
 * <br></br>
 * <br></br>
 * CAUTION: Authorized personnel only. Do not modify or refactor.
 *
 * @author gregsh
 */
private const val MAX_VARIANTS_SIZE = 10000
private const val MAX_VARIANTS_TO_DISPLAY = 50
private const val MAX_ERROR_TOKEN_TEXT = 20
private const val MAX_CHILDREN_IN_TREE = 10

private const val INITIAL_VARIANTS_SIZE = 1000
private const val VARIANTS_POOL_SIZE = 10000
private const val FRAMES_POOL_SIZE = 500

// here's the new section API for compact parsers & less IntelliJ platform API exposure
val _NONE_: Int = 0x0
val _COLLAPSE_: Int = 0x1
val _LEFT_: Int = 0x2
val _LEFT_INNER_: Int = 0x4
val _AND_: Int = 0x8
val _NOT_: Int = 0x10
val _UPPER_: Int = 0x20

open class SyntaxGeneratedParserRuntimeBase(
  protected val MAX_RECURSION_LEVEL: Int = 1000,
  protected val isLanguageCaseSensitive: Boolean,
  protected val bundle: BundleAdapter,
  protected val lexer: Lexer,
  protected val parser: (SyntaxElementType, SyntaxTreeBuilder) -> Unit,
  protected val braces: Collection<BracePair>,
) {
  private val LOG: Logger = NoopLogger

  //private val MAX_RECURSION_LEVEL = StringUtil.parseInt(System.getProperty("grammar.kit.gpub.max.level"), 1000)
  companion object {

    fun isWhitespaceOrComment(builder: SyntaxTreeBuilder, type: SyntaxElementType?): Boolean {
      return type != null && builder.isWhitespaceOrComment(type)
    }

    val TOKEN_ADVANCER: Parser = object : Parser {
      override fun parse(builder: SyntaxTreeBuilder, level: Int): Boolean {
        if (builder.eof()) return false
        builder.advanceLexer()
        return true
      }
    }

    val TRUE_CONDITION: Parser = object : Parser {
      override fun parse(builder: SyntaxTreeBuilder, level: Int): Boolean = true
    }

    val LEFT_BINDER: Hook<WhitespacesAndCommentsBinder?> = object : Hook<WhitespacesAndCommentsBinder?> {
      override fun run(builder: SyntaxTreeBuilder, marker: SyntaxTreeBuilder.Marker?, param: WhitespacesAndCommentsBinder?): SyntaxTreeBuilder.Marker? {
        marker?.setCustomEdgeTokenBinders(param, null)
        return marker
      }
    }

    val RIGHT_BINDER: Hook<WhitespacesAndCommentsBinder?> = object : Hook<WhitespacesAndCommentsBinder?> {

      override fun run(builder: SyntaxTreeBuilder, marker: SyntaxTreeBuilder.Marker?, param: WhitespacesAndCommentsBinder?): SyntaxTreeBuilder.Marker? {
        marker?.setCustomEdgeTokenBinders(null, param)
        return marker
      }
    }

    val WS_BINDERS: Hook<Array<WhitespacesAndCommentsBinder?>> = object : Hook<Array<WhitespacesAndCommentsBinder?>> {
      override fun run(builder: SyntaxTreeBuilder, marker: SyntaxTreeBuilder.Marker?, param: Array<WhitespacesAndCommentsBinder?>?): SyntaxTreeBuilder.Marker? {
        marker?.setCustomEdgeTokenBinders(param!![0], param[1])
        return marker
      }
    }

    val DUMMY_BLOCK: SyntaxElementType = SyntaxElementType("DUMMY_BLOCK")
  }

  fun eof(builder: SyntaxTreeBuilder, level: Int): Boolean {
    return builder.eof()
  }

  fun current_position_(builder: SyntaxTreeBuilder): Int {
    return builder.rawTokenIndex()
  }

  fun recursion_guard_(builder: SyntaxTreeBuilder, level: Int, funcName: String?): Boolean {
    if (level > MAX_RECURSION_LEVEL) {
      builder.mark().error(bundle.message("parsing.error.maximum.recursion.level.reached.in", MAX_RECURSION_LEVEL, funcName))
      return false
    }
    return true
  }

  fun empty_element_parsed_guard_(builder: SyntaxTreeBuilder, funcName: String, pos: Int): Boolean {
    if (pos == current_position_(builder)) {
      // sometimes this is a correct situation, therefore no explicit marker
      builder.error(bundle.message("parsing.error.empty.element.parsed.in.at.offset", funcName, builder.currentOffset))
      return false
    }
    return true
  }

  fun invalid_left_marker_guard_(builder: SyntaxTreeBuilder, marker: SyntaxTreeBuilder.Marker?, funcName: String?): Boolean {
    //builder.error("Invalid left marker encountered in " + funcName_ +" at offset " + builder.getCurrentOffset());
    val goodMarker = marker != null // && ((LighterASTNode)marker).getTokenType() != TokenType.ERROR_ELEMENT;
    if (!goodMarker) return false
    val state: ErrorState = ErrorState.get(builder)

    return state.currentFrame != null
  }

  fun create_token_set_(vararg tokenTypes: SyntaxElementType?): Set<SyntaxElementType?> {
    return tokenTypes.toSet()
  }

  fun leftMarkerIs(builder: SyntaxTreeBuilder, type: SyntaxElementType?): Boolean {
    val lastDoneMarker = builder.lastDoneMarker
    return lastDoneMarker?.getTokenType() === type
  }

  private fun consumeTokens(builder: SyntaxTreeBuilder, smart: Boolean, pin: Int, vararg tokens: SyntaxElementType?): Boolean {
    val state = ErrorState.get(builder)
    if (state.completionState != null && state.predicateSign) {
      (builder as? CompletionVariantProvider)?.addCompletionVariant(builder, state.completionState, tokens)
    }
    // suppress single token completion
    val completionState: CompletionState? = state.completionState
    state.completionState = null
    var result = true
    var pinned = false
    var i = 0
    val tokensLength = tokens.size
    while (i < tokensLength) {
      if (pin > 0 && i == pin) pinned = result
      if (result || pinned) {
        val fast = smart && i == 0
        tokens[i]?.let {
          if (!(if (fast) consumeTokenFast(builder, it) else consumeToken(builder, it))) {
            result = false
            if (pin < 0 || pinned) report_error_(builder, state, false)
          }
        }
      }
      i++
    }
    state.completionState = completionState
    return pinned || result
  }

  fun consumeTokens(builder: SyntaxTreeBuilder, pin: Int, vararg token: SyntaxElementType?): Boolean {
    return consumeTokens(builder, false, pin, *token)
  }

  fun consumeTokensSmart(builder: SyntaxTreeBuilder, pin: Int, vararg token: SyntaxElementType?): Boolean {
    return consumeTokens(builder, true, pin, *token)
  }

  fun parseTokens(builder: SyntaxTreeBuilder, pin: Int, vararg tokens: SyntaxElementType?): Boolean {
    return parseTokens(builder, false, pin, *tokens)
  }

  fun parseTokensSmart(builder: SyntaxTreeBuilder, pin: Int, vararg tokens: SyntaxElementType?): Boolean {
    return parseTokens(builder, true, pin, *tokens)
  }

  fun parseTokens(builder: SyntaxTreeBuilder, smart: Boolean, pin: Int, vararg tokens: SyntaxElementType?): Boolean {
    val marker: SyntaxTreeBuilder.Marker = builder.mark()
    val result: Boolean = consumeTokens(builder, smart, pin, *tokens)
    if (!result) {
      marker.rollbackTo()
    }
    else {
      marker.drop()
    }
    return result
  }

  fun consumeTokenSmart(builder: SyntaxTreeBuilder, token: SyntaxElementType): Boolean {
    (builder as? CompletionVariantProvider)?.addCompletionVariantSmart(builder, token)
    return consumeTokenFast(builder, token)
  }

  fun consumeTokenSmart(builder: SyntaxTreeBuilder, token: String): Boolean {
    (builder as? CompletionVariantProvider)?.addCompletionVariantSmart(builder, token)
    return consumeTokenFast(builder, token)
  }

  @Contract(mutates = "param1")
  fun consumeToken(builder: SyntaxTreeBuilder, token: SyntaxElementType): Boolean {
    addVariantSmart(builder, token, true)
    return consumeTokenFast(builder, token)
  }

  fun consumeTokenFast(builder: SyntaxTreeBuilder, token: SyntaxElementType): Boolean {
    if (nextTokenIsFast(builder, token)) {
      builder.advanceLexer()
      return true
    }
    return false
  }

  @JvmOverloads
  fun consumeToken(builder: SyntaxTreeBuilder, text: String, caseSensitive: Boolean = ErrorState.Companion.get(builder).caseSensitive): Boolean {
    addVariantSmart(builder, text, true)
    var count: Int = nextTokenIsFast(builder, text, caseSensitive)
    if (count > 0) {
      while (count-- > 0) builder.advanceLexer()
      return true
    }
    return false
  }

  fun consumeTokenFast(builder: SyntaxTreeBuilder, text: String): Boolean {
    var count: Int = nextTokenIsFast(builder, text, ErrorState.Companion.get(builder).caseSensitive)
    if (count > 0) {
      while (count-- > 0) builder.advanceLexer()
      return true
    }
    return false
  }

  fun consumeToken(builder: SyntaxTreeBuilder, tokens: Set<SyntaxElementType>): Boolean {
    addVariantSmart(builder, tokens, true)
    return consumeTokenFast(builder, tokens)
  }

  fun consumeTokenSmart(builder: SyntaxTreeBuilder, tokens: Set<SyntaxElementType>): Boolean {
    (builder as? CompletionVariantProvider)?.addCompletionVariantSmart(builder, tokens)
    return consumeTokenFast(builder, tokens)
  }

  fun consumeTokenFast(builder: SyntaxTreeBuilder, tokens: Set<SyntaxElementType>): Boolean {
    if (nextTokenIsFast(builder, tokens)) {
      builder.advanceLexer()
      return true
    }
    return false
  }

  fun nextTokenIsFast(builder: SyntaxTreeBuilder, token: SyntaxElementType?): Boolean {
    return builder.tokenType === token
  }

  fun nextTokenIsFast(builder: SyntaxTreeBuilder, vararg tokens: SyntaxElementType): Boolean {
    val tokenType: SyntaxElementType? = builder.tokenType
    return tokens.indexOf(tokenType) >= 0
  }

  fun nextTokenIsFast(builder: SyntaxTreeBuilder, tokens: Set<SyntaxElementType>): Boolean {
    return tokens.contains(builder.tokenType)
  }

  fun nextTokenIsSmart(builder: SyntaxTreeBuilder, token: SyntaxElementType?): Boolean {
    return nextTokenIsFast(builder, token) || ErrorState.Companion.get(builder).completionState != null
  }

  fun nextTokenIsSmart(builder: SyntaxTreeBuilder, vararg tokens: SyntaxElementType): Boolean {
    return nextTokenIsFast(builder, *tokens) || ErrorState.Companion.get(builder).completionState != null
  }

  fun nextTokenIs(builder: SyntaxTreeBuilder, frameName: String?, vararg tokens: SyntaxElementType): Boolean {
    val state: ErrorState = ErrorState.Companion.get(builder)
    if (state.completionState != null) return true
    val track = !state.suppressErrors && state.predicateCount < 2 && state.predicateSign
    return if (!track) nextTokenIsFast(builder, *tokens) else nextTokenIsSlow(builder, frameName, *tokens)
  }

  fun nextTokenIsSlow(builder: SyntaxTreeBuilder, frameName: String?, vararg tokens: SyntaxElementType): Boolean {
    val state: ErrorState = ErrorState.Companion.get(builder)
    val tokenType: SyntaxElementType? = builder.tokenType
    if (!frameName.isNullOrEmpty()) {
      addVariantInner(state, state.currentFrame, builder.rawTokenIndex(), frameName)
    }
    else {
      for (token in tokens) {
        addVariant(builder, state, token)
      }
    }
    if (tokenType == null) return false
    return tokens.indexOf(tokenType) != -1
  }

  fun nextTokenIs(builder: SyntaxTreeBuilder, token: SyntaxElementType): Boolean {
    if (!addVariantSmart(builder, token, false)) return true
    return nextTokenIsFast(builder, token)
  }

  fun nextTokenIs(builder: SyntaxTreeBuilder, tokenText: String): Boolean {
    if (!addVariantSmart(builder, tokenText, false)) return true
    return nextTokenIsFast(builder, tokenText, ErrorState.Companion.get(builder).caseSensitive) > 0
  }

  fun nextTokenIsFast(builder: SyntaxTreeBuilder, tokenText: String): Boolean {
    return nextTokenIsFast(builder, tokenText, ErrorState.Companion.get(builder).caseSensitive) > 0
  }

  fun nextTokenIsFast(builder: SyntaxTreeBuilder, tokenText: String, caseSensitive: Boolean): Int {
    val sequence: CharSequence = builder.text
    val offset: Int = builder.currentOffset
    val endOffset = offset + tokenText.length
    val subSequence = sequence.subSequence(offset, min(endOffset.toDouble(), sequence.length.toDouble()).toInt())
    if (!subSequence.contentEquals(tokenText, caseSensitive)) return 0

    var count = 0
    while (true) {
      val nextOffset: Int = builder.rawTokenTypeStart(++count)
      if (nextOffset > endOffset) {
        return -count
      }
      else if (nextOffset == endOffset) {
        break
      }
    }
    return count
  }

  private fun addVariantSmart(builder: SyntaxTreeBuilder, token: Any, force: Boolean): Boolean {
    val state: ErrorState = ErrorState.Companion.get(builder)
    // skip FIRST check in completion mode
    if (state.completionState != null && !force) return false
    builder.eof()
    if (!state.suppressErrors && state.predicateCount < 2) {
      addVariant(builder, state, token)
    }
    return true
  }

  fun addVariant(builder: SyntaxTreeBuilder, text: String) {
    addVariant(builder, ErrorState.Companion.get(builder), text)
  }

  private fun addVariant(builder: SyntaxTreeBuilder, state: ErrorState, o: Any) {
    builder.eof() // skip whitespaces
    addVariantInner(state, state.currentFrame, builder.rawTokenIndex(), o)

    val completionState: CompletionState? = state.completionState
    if (completionState != null && state.predicateSign) {
      (builder as? CompletionVariantProvider)?.addCompletionVariant(builder, completionState, o)
    }
  }

  private fun addVariantInner(state: ErrorState, frame: Frame?, pos: Int, o: Any?) {
    val variant: Variant = state.VARIANTS.alloc().init(pos, o)
    if (state.predicateSign) {
      state.variants.add(variant)
      if (frame != null && frame.lastVariantAt < pos) {
        frame.lastVariantAt = pos
      }
    }
    else {
      state.unexpected.add(variant)
    }
  }

  private fun wasAutoSkipped(builder: SyntaxTreeBuilder, steps: Int): Boolean {
    for (i in -1 downTo -steps) {
      if (!isWhitespaceOrComment(builder, builder.rawLookup(i))) return false
    }
    return true
  }

  // simple enter/exit methods pair that doesn't require frame object
  fun enter_section_(builder: SyntaxTreeBuilder): SyntaxTreeBuilder.Marker {
    val state: ErrorState = ErrorState.Companion.get(builder)
    reportFrameError(builder, state)
    state.level++
    return builder.mark()
  }

  fun exit_section_(
    builder: SyntaxTreeBuilder,
    marker: SyntaxTreeBuilder.Marker?,
    elementType: SyntaxElementType?,
    result: Boolean,
  ) {
    val state: ErrorState = ErrorState.Companion.get(builder)
    close_marker_impl_(state.currentFrame, marker, elementType, result)
    run_hooks_impl_(builder, state, if (result) elementType else null)
    state.level--
  }

  // complex enter/exit methods pair with frame object
  fun enter_section_(builder: SyntaxTreeBuilder, level: Int, modifiers: Int, frameName: String?): SyntaxTreeBuilder.Marker {
    return enter_section_(builder, level, modifiers, null, frameName)
  }

  @JvmOverloads
  fun enter_section_(builder: SyntaxTreeBuilder, level: Int, modifiers: Int, elementType: SyntaxElementType? = null, frameName: String? = null): SyntaxTreeBuilder.Marker {
    reportFrameError(builder, ErrorState.Companion.get(builder))
    val marker: SyntaxTreeBuilder.Marker = builder.mark()
    enter_section_impl_(builder, level, modifiers, elementType, frameName)
    return marker
  }

  private fun enter_section_impl_(builder: SyntaxTreeBuilder, level: Int, modifiers: Int, elementType: SyntaxElementType?, frameName: String?) {
    val state: ErrorState = ErrorState.Companion.get(builder)
    state.level++
    val frame: Frame = state.FRAMES.alloc().init(builder, state, level, modifiers, elementType, frameName)
    if (((frame.modifiers and _LEFT_) or (frame.modifiers and _LEFT_INNER_)) != 0) {
      val left: SyntaxTreeBuilder.Marker? = builder.lastDoneMarker
      if (invalid_left_marker_guard_(builder, left, frameName)) {
        frame.leftMarker = left
      }
    }
    state.currentFrame = frame
    if ((modifiers and _AND_) != 0) {
      if (state.predicateCount == 0 && !state.predicateSign) {
        throw AssertionError("Incorrect false predicate sign")
      }
      state.predicateCount++
    }
    else if ((modifiers and _NOT_) != 0) {
      state.predicateSign = state.predicateCount != 0 && !state.predicateSign
      state.predicateCount++
    }
  }

  fun exit_section_(
    builder: SyntaxTreeBuilder,
    level: Int,
    marker: SyntaxTreeBuilder.Marker?,
    result: Boolean,
    pinned: Boolean,
    eatMore: Parser?,
  ) {
    exit_section_(builder, level, marker, null, result, pinned, eatMore)
  }

  fun exit_section_(
    builder: SyntaxTreeBuilder,
    level: Int,
    marker: SyntaxTreeBuilder.Marker?,
    elementType: SyntaxElementType?,
    result: Boolean,
    pinned: Boolean,
    eatMore: Parser?,
  ) {
    var elementType: SyntaxElementType? = elementType
    val state: ErrorState = ErrorState.Companion.get(builder)

    val frame: Frame? = state.currentFrame
    state.currentFrame = if (frame == null) null else frame.parentFrame
    if (frame != null && frame.elementType != null) elementType = frame.elementType
    if (frame == null || level != frame.level) {
      LOG.error("Unbalanced error section: got " + frame + ", expected level " + level)
      if (frame != null) state.FRAMES.recycle(frame)
      close_marker_impl_(frame, marker, elementType, result)
      return
    }

    close_frame_impl_(state, frame, builder, marker, elementType, result, pinned)
    exit_section_impl_(state, frame, builder, elementType, result, pinned, eatMore)
    run_hooks_impl_(builder, state, if (pinned || result) elementType else null)
    state.FRAMES.recycle(frame)
    state.level--
  }

  fun <T> register_hook_(builder: SyntaxTreeBuilder, hook: Hook<T?>?, param: T?) {
    val state: ErrorState = ErrorState.Companion.get(builder)
    state.hooks = Hooks.Companion.concat<T?>(hook, param, state.level, state.hooks)
  }

  @SafeVarargs
  fun <T> register_hook_(builder: SyntaxTreeBuilder, hook: Hook<Array<T?>?>?, vararg param: T?) {
    val state: ErrorState = ErrorState.Companion.get(builder)
    state.hooks = Hooks.Companion.concat<Array<T?>?>(hook, arrayOf(param.asIterable()), state.level, state.hooks)
  }

  private fun run_hooks_impl_(builder: SyntaxTreeBuilder, state: ErrorState, elementType: SyntaxElementType?) {
    state.hooks?.let { hooks ->
      var marker: SyntaxTreeBuilder.Marker? = if (elementType == null) null else builder.lastDoneMarker
      if (elementType != null && marker == null) {
        builder.mark().error(bundle.message("parsing.error.no.expected.done.marker.at.offset", builder.currentOffset))
      }
      while (hooks.level >= state.level) {
        if (hooks.level == state.level) {
          marker = (hooks.hook as Hook<*>).run(builder, marker, hooks.param)
        }
        state.hooks = hooks.next
      }
    }
  }

  private fun exit_section_impl_(
    state: ErrorState,
    frame: Frame,
    builder: SyntaxTreeBuilder,
    elementType: SyntaxElementType?,
    result: Boolean,
    pinned: Boolean,
    eatMore: Parser?,
  ) {
    val initialPos: Int = builder.rawTokenIndex()
    replace_variants_with_name_(state, frame, builder, elementType, result, pinned)
    val lastErrorPos = if (frame.lastVariantAt < 0) initialPos else frame.lastVariantAt
    if (!state.suppressErrors && eatMore != null) {
      state.suppressErrors = true
      val eatMoreFlagOnce = !builder.eof() && eatMore.parse(builder, frame.level + 1)
      var eatMoreFlag = eatMoreFlagOnce || !result && frame.position == initialPos && lastErrorPos > frame.position

      val latestDoneMarker: SyntaxTreeBuilder.Marker? =
        if ((pinned || result) && (state.altMode || elementType != null) &&
            eatMoreFlagOnce) getLatestExtensibleDoneMarker(builder)
        else null
      // advance to the last error pos
      // skip tokens until lastErrorPos. parseAsTree might look better here...
      var parenCount = 0
      while ((eatMoreFlag || parenCount > 0) && builder.rawTokenIndex() < lastErrorPos) {
        val tokenType: SyntaxElementType? = builder.tokenType
        parenCount = state.braces?.let { braces ->
          if (tokenType === braces[0].myLeftBrace) return@let 1
          else if (tokenType === braces[0].myRightBrace) return@let -1
          return@let 0
        } ?: 0
        if (builder.rawTokenIndex() >= lastErrorPos) break
        state.tokenAdvancer.parse(builder, frame.level + 1)
        eatMoreFlag = eatMore.parse(builder, frame.level + 1)
      }
      var errorReported = frame.errorReportedAt == initialPos || !result && frame.errorReportedAt >= frame.position
      if (errorReported || eatMoreFlag) {
        if (!errorReported) {
          errorReported = reportError(builder, state, frame, false, true, true)
        }
        else if (eatMoreFlag) {
          state.tokenAdvancer.parse(builder, frame.level + 1)
        }
        if (eatMore.parse(builder, frame.level + 1)) {
          parseAsTree(state, builder, frame.level + 1, DUMMY_BLOCK, true, state.tokenAdvancer, eatMore)
        }
      }
      else if (eatMoreFlagOnce || !result && frame.position != builder.rawTokenIndex() || frame.errorReportedAt > initialPos) {
        errorReported = reportError(builder, state, frame, false, true, false)
      }
      else if (!result && pinned && frame.errorReportedAt < 0) {
        errorReported = reportError(builder, state, frame, elementType != null, false, false)
      }
      // whitespace prefix makes the very first frame offset bigger than marker start offset which is always 0
      if (latestDoneMarker != null && frame.position >= latestDoneMarker.getStartIndex() && frame.position <= latestDoneMarker.getEndIndex()) {
        extend_marker_impl(latestDoneMarker)
      }
      state.suppressErrors = false
      if (errorReported || result) {
        state.clearVariants(true, 0)
        state.clearVariants(false, 0)
        frame.lastVariantAt = -1
        var f: Frame? = frame
        while (f != null && f.variantCount > 0) {
          f.variantCount = 0
          f = f.parentFrame
        }
      }
    }
    else if (!result && pinned && frame.errorReportedAt < 0) {
      // do not report if there are errors beyond current position
      if (lastErrorPos == initialPos) {
        // do not force, inner recoverRoot might have skipped some tokens
        reportError(builder, state, frame, elementType != null && (frame.modifiers and _UPPER_) == 0, false, false)
      }
      else if (lastErrorPos > initialPos) {
        // set error pos here as if it is reported for future reference
        frame.errorReportedAt = lastErrorPos
      }
    }
    // propagate errorReportedAt up the stack to avoid duplicate reporting
    state.currentFrame?.let { currentFrame ->
      if (currentFrame.errorReportedAt < frame.errorReportedAt) {
        currentFrame.errorReportedAt = frame.errorReportedAt
      }
      if (currentFrame.lastVariantAt < frame.lastVariantAt) {
        currentFrame.lastVariantAt = frame.lastVariantAt
      }
    }

  }

  private fun close_frame_impl_(
    state: ErrorState,
    frame: Frame,
    builder: SyntaxTreeBuilder,
    marker: SyntaxTreeBuilder.Marker?,
    elementType: SyntaxElementType?,
    result: Boolean,
    pinned: Boolean,
  ) {
    var marker: SyntaxTreeBuilder.Marker? = marker
    var elementType: SyntaxElementType? = elementType
    if (((frame.modifiers and _AND_) or (frame.modifiers and _NOT_)) != 0) {
      val resetLastPos = !state.suppressErrors && frame.lastVariantAt < 0 && frame.position < builder.rawTokenIndex()
      close_marker_impl_(frame, marker, null, false)
      state.predicateCount--
      if ((frame.modifiers and _NOT_) != 0) state.predicateSign = !state.predicateSign
      marker = if (elementType != null && marker != null && (result || pinned)) builder.mark() else null
      if (resetLastPos) frame.lastVariantAt = builder.rawTokenIndex()
    }
    if (elementType != null && marker != null) {
      if (result || pinned) {
        if ((frame.modifiers and _COLLAPSE_) != 0) {
          val last: SyntaxTreeBuilder.Marker? = builder.lastDoneMarker
          if (last != null && last.getStartIndex() == frame.position &&
              state.typeExtends(last.getTokenType(), elementType) &&
              wasAutoSkipped(builder, builder.rawTokenIndex() - last.getEndIndex())) {
            elementType = last.getTokenType()
            last.drop()
          }
        }
        if ((frame.modifiers and _UPPER_) != 0) {
          marker.drop()
          var f: Frame? = frame.parentFrame
          while (f != null) {
            if (f.elementType == null) {
              f = f.parentFrame
              continue
            }
            f.elementType = elementType
            break
            f = f.parentFrame
          }
        }
        else if ((frame.modifiers and _LEFT_INNER_) != 0 && frame.leftMarker != null) {
          marker.done(elementType)
          frame.leftMarker?.let{extend_marker_impl(it)}
        }
        else if ((frame.modifiers and _LEFT_) != 0 && frame.leftMarker != null) {
          marker.drop()
          frame.leftMarker?.precede()?.done(elementType)
        }
        else {
          if (frame.level == 0) builder.eof() // skip whitespaces

          marker.done(elementType)
        }
      }
      else {
        close_marker_impl_(frame, marker, null, false)
      }
    }
    else if (result || pinned) {
      marker?.drop()
      if ((frame.modifiers and _LEFT_INNER_) != 0 && frame.leftMarker != null) {
        extend_marker_impl(frame.leftMarker!!)
      }
    }
    else {
      close_marker_impl_(frame, marker, null, false)
    }
  }

  private fun extend_marker_impl(marker: SyntaxTreeBuilder.Marker) {
    val precede: SyntaxTreeBuilder.Marker = marker.precede()
    val elementType: SyntaxElementType = marker.getTokenType()
    if (elementType === SyntaxTokenTypes.ERROR_ELEMENT) {
      precede.error(marker.getErrorMessage() ?: "")
    }
    else {
      precede.done(elementType)
    }
    marker.drop()
  }

  private fun close_marker_impl_(frame: Frame?, marker: SyntaxTreeBuilder.Marker?, elementType: SyntaxElementType?, result: Boolean) {
    if (marker == null) return
    if (result) {
      if (elementType != null) {
        marker.done(elementType)
      }
      else {
        marker.drop()
      }
    }
    else {
      frame?.let {
        val position: Int = marker.getStartIndex()
        if (frame.errorReportedAt > position) {
          frame.errorReportedAt = frame.parentFrame?.let { parentFrame -> parentFrame.errorReportedAt } ?: -1
        }
      }
      marker.rollbackTo()
    }
  }

  private fun replace_variants_with_name_(
    state: ErrorState,
    frame: Frame,
    builder: SyntaxTreeBuilder,
    elementType: SyntaxElementType?,
    result: Boolean,
    pinned: Boolean,
  ) {
    val initialPos: Int = builder.rawTokenIndex()
    val willFail = !result && !pinned
    if (willFail && initialPos == frame.position && frame.lastVariantAt == frame.position && frame.name != null && state.variants.size >= frame.variantCount + (if (elementType == null) 0 else 2)) {
      state.clearVariants(true, frame.variantCount)
      addVariantInner(state, frame, initialPos, frame.name)
    }
  }

  fun report_error_(builder: SyntaxTreeBuilder, result: Boolean): Boolean {
    if (!result) report_error_(builder, ErrorState.Companion.get(builder), false)
    return result
  }

  fun report_error_(builder: SyntaxTreeBuilder, state: ErrorState, advance: Boolean) {
    val frame: Frame? = state.currentFrame
    if (frame == null) {
      LOG.error("unbalanced enter/exit section call: got null")
      return
    }
    val position: Int = builder.rawTokenIndex()
    if (frame.errorReportedAt < position && frame.lastVariantAt > -1 && frame.lastVariantAt <= position) {
      reportError(builder, state, frame, false, true, advance)
    }
  }

  private fun getLatestExtensibleDoneMarker(builder: SyntaxTreeBuilder): SyntaxTreeBuilder.Marker? {
    val marker: SyntaxTreeBuilder.Production? = builder.productions.last()
    if (marker == null || marker.isCollapsed()) return null
    return marker as? SyntaxTreeBuilder.Marker
  }

  private fun reportError(
    builder: SyntaxTreeBuilder,
    state: ErrorState,
    frame: Frame,
    inner: Boolean,
    force: Boolean,
    advance: Boolean,
  ): Boolean {
    val position: Int = builder.rawTokenIndex()
    val expected: String = state.getExpected(position, true)
    if (!force && expected.isEmpty() && !advance) return false

    val actual: CharSequence? = builder.text.trim()
    val message: String
    if (expected.isEmpty()) {
      if (actual.isNullOrEmpty()) {
        message = bundle.message("parsing.error.unmatched.input")
      }
      else {
        message = bundle.message("parsing.error.unexpected", actual.crop(MAX_ERROR_TOKEN_TEXT, true))
      }
    }
    else {
      if (actual.isNullOrEmpty()) {
        message = bundle.message("parsing.error.expected", expected)
      }
      else {
        message = bundle.message("parsing.error.expected.got", expected, actual.crop(MAX_ERROR_TOKEN_TEXT, true))
      }
    }
    if (advance) {
      val mark: SyntaxTreeBuilder.Marker = builder.mark()
      state.tokenAdvancer.parse(builder, frame.level + 1)
      mark.error(message)
    }
    else if (inner) {
      val latestDoneMarker: SyntaxTreeBuilder.Marker? = getLatestExtensibleDoneMarker(builder)
      builder.error(message)
      if (latestDoneMarker != null && frame.position >= latestDoneMarker.getStartIndex() && frame.position <= latestDoneMarker.getEndIndex()) {
        extend_marker_impl(latestDoneMarker)
      }
    }
    else {
      builder.error(message)
    }
    builder.eof() // skip whitespaces
    frame.errorReportedAt = builder.rawTokenIndex()
    return true
  }

  private fun reportFrameError(builder: SyntaxTreeBuilder, state: ErrorState) {
    if (state.currentFrame == null || state.suppressErrors) return
    val frame: Frame? = state.currentFrame
    val pos: Int = builder.rawTokenIndex()
    if (frame != null && frame.errorReportedAt > pos) {
      // report error for previous unsuccessful frame
      val marker: SyntaxTreeBuilder.Marker? = builder.lastDoneMarker
      var endOffset = marker?.getEndIndex() ?: (pos + 1)
      while (endOffset <= pos && isWhitespaceOrComment(builder, builder.rawLookup(endOffset - pos))) endOffset++
      val inner = endOffset == pos
      builder.eof()
      reportError(builder, state, frame, inner, true, false)
    }
  }


  @JvmOverloads
  fun init_runtime_(root: SyntaxElementType, builder: SyntaxTreeBuilder, extendsSets: Array<Set<SyntaxElementType>>? = null) {
    val state: ErrorState = ErrorState(bundle)
    ErrorState.Companion.initState(state, builder, root, this, extendsSets)
  }

  private fun checkSiblings(
    chunkType: SyntaxElementType,
    parens: ArrayDeque<Pair<SyntaxTreeBuilder.Marker?, SyntaxTreeBuilder.Marker?>>,
    siblings: ArrayDeque<Pair<SyntaxTreeBuilder.Marker, Int>>,
  ) {
    main@ while (!siblings.isEmpty()) {
      val parenPair: Pair<SyntaxTreeBuilder.Marker?, SyntaxTreeBuilder.Marker?> = parens.first()
      val rating: Int = siblings.first().second
      var count = 0
      for (pair in siblings) {
        if (pair.second != rating || pair.first === parenPair.second) break@main
        if (++count >= MAX_CHILDREN_IN_TREE) {
          val parentMarker: SyntaxTreeBuilder.Marker = pair.first.precede()
          parentMarker.setCustomEdgeTokenBinders(WhitespacesBinders.greedyLeftBinder(), null)
          while (count-- > 0) {
            siblings.removeFirst()
          }
          parentMarker.done(chunkType)
          siblings.addFirst(Pair(parentMarker, rating + 1))
          continue@main
        }
      }
      break
    }
  }

  fun parseAsTree(
    state: ErrorState, builder: SyntaxTreeBuilder, level: Int,
    chunkType: SyntaxElementType, checkBraces: Boolean,
    parser: Parser, eatMoreCondition: Parser,
  ): Boolean {
    val parens: ArrayDeque<Pair<SyntaxTreeBuilder.Marker?, SyntaxTreeBuilder.Marker?>> = ArrayDeque<Pair<SyntaxTreeBuilder.Marker?, SyntaxTreeBuilder.Marker?>>(4)
    val siblings: ArrayDeque<Pair<SyntaxTreeBuilder.Marker, Int>> = ArrayDeque<Pair<SyntaxTreeBuilder.Marker, Int>>()
    var marker: SyntaxTreeBuilder.Marker? = null

    val lBrace: SyntaxElementType? = state.braces?.let { braces -> if (checkBraces && braces.size > 0) braces[0].myLeftBrace else null }
    val rBrace: SyntaxElementType? = if (lBrace != null) state.braces?.let { braces -> braces[0].myRightBrace } else null
    var totalCount = 0
    var tokenCount = 0
    if (lBrace != null) {
      var tokenIdx = -1
      while (builder.rawLookup(tokenIdx) === SyntaxTokenTypes.WHITE_SPACE) tokenIdx--
      val doneMarker = if (builder.rawLookup(tokenIdx) === lBrace) builder.lastDoneMarker else null
      if (doneMarker != null && doneMarker.getStartOffset() == builder.rawTokenTypeStart(tokenIdx) && doneMarker.getTokenType() === SyntaxTokenTypes.ERROR_ELEMENT) {
        parens.add(Pair(doneMarker.precede(), null))
      }
    }
    var c: Int = current_position_(builder)
    while (true) {
      val tokenType: SyntaxElementType? = builder.tokenType
      if (lBrace != null && (tokenType === lBrace || tokenType === rBrace && !parens.isEmpty())) {
        if (marker != null) {
          marker.done(chunkType)
          siblings.addFirst(Pair(marker, 1))
          marker = null
          tokenCount = 0
        }
        if (tokenType === lBrace) {
          val prev = siblings.first()
          parens.addFirst(Pair(builder.mark(), prev.first))
        }
        checkSiblings(chunkType, parens, siblings)
        state.tokenAdvancer.parse(builder, level)
        if (tokenType === rBrace) {
          val pair: Pair<SyntaxTreeBuilder.Marker?, SyntaxTreeBuilder.Marker?> = parens.removeFirst()
          pair.first?.done(chunkType)
          // drop all markers inside parens
          while (!siblings.isEmpty() && siblings.first().first !== pair.second) {
            siblings.removeFirst()
          }
          siblings.addFirst(Pair(pair.first, 1))
          checkSiblings(chunkType, parens, siblings)
        }
      }
      else {
        if (marker == null) {
          marker = builder.mark()
          marker.setCustomEdgeTokenBinders(WhitespacesBinders.greedyLeftBinder(), null)
        }
        val result = (!parens.isEmpty() || eatMoreCondition.parse(builder, level + 1)) &&
                     parser.parse(builder, level + 1)
        if (result) {
          tokenCount++
          totalCount++
        }
        else {
          break
        }
      }

      if (tokenCount >= MAX_CHILDREN_IN_TREE) {
        marker?.done(chunkType)
        siblings.addFirst(Pair(marker, 1))
        checkSiblings(chunkType, parens, siblings)
        marker = null
        tokenCount = 0
      }
      if (!empty_element_parsed_guard_(builder, "parseAsTree", c)) break
      c = current_position_(builder)
    }
    if (marker != null) marker.drop()
    for (pair in parens) {
      pair.first?.drop()
    }
    return totalCount != 0
  }

  interface Parser {
    fun parse(builder: SyntaxTreeBuilder, level: Int): Boolean
  }

  class Builder(private val builder: SyntaxTreeBuilder, state_: ErrorState) {
    val state: ErrorState

    init {
      state = state_
    }

    val lexer: Lexer
      get() = this.lexer

    internal val productions: MutableList<SyntaxTreeBuilder.Production>
      get() = builder.productions.toMutableList()
  }


  interface Hook<T> {
    @Contract("_,null,_->null")
    fun run(builder: SyntaxTreeBuilder, marker: SyntaxTreeBuilder.Marker?, param: T?): SyntaxTreeBuilder.Marker?
  }

  internal class Hooks<T>(val hook: Hook<T?>?, param: T?, level: Int, next: Hooks<*>?) {
    val param: T?
    val level: Int
    val next: Hooks<*>?

    init {
      this.param = param
      this.level = level
      this.next = next
    }

    companion object {
      fun <E> concat(hook: Hook<E?>?, param: E?, level: Int, hooks: Hooks<*>?): Hooks<E?> {
        return Hooks<E?>(hook, param, level, hooks)
      }
    }
  }

  internal class MyList<E>(initialCapacity: Int) : ArrayList<E>(initialCapacity) {
    fun setSize(fromIndex: Int) {
      removeRange(fromIndex, size)
    }

    override fun add(e: E): Boolean {
      val size = size
      if (size >= MAX_VARIANTS_SIZE) {
        removeRange(MAX_VARIANTS_SIZE / 4, size - MAX_VARIANTS_SIZE / 4)
      }
      return super.add(e)
    }
  }

  class ErrorState(val bundle: BundleAdapter) {
    internal var currentFrame: Frame? = null
    var completionState: CompletionState? = null
    internal val variants: MyList<Variant> = MyList<Variant>(INITIAL_VARIANTS_SIZE)
    internal val unexpected: MyList<Variant> = MyList<Variant>(INITIAL_VARIANTS_SIZE / 10)

    var predicateCount: Int = 0
    var level: Int = 0
    var predicateSign: Boolean = true
    var suppressErrors: Boolean = false
    internal var hooks: Hooks<*>? = null

    var extendsSets: Array<Set<SyntaxElementType>>? = null
    var caseSensitive = false
    var braces: Array<BracePair>? = null
    var tokenAdvancer: Parser = TOKEN_ADVANCER
    var altMode: Boolean = false

    internal val VARIANTS: LimitedPool<Variant> = LimitedPool<Variant>(VARIANTS_POOL_SIZE){ Variant() }
    val FRAMES: LimitedPool<Frame> = LimitedPool<Frame>(FRAMES_POOL_SIZE){ Frame() }

    fun getExpected(position: Int, expected: Boolean): String {
      val sb = StringBuilder()
      val list = if (expected) variants else unexpected
      val strings: Array<String?> = arrayOfNulls<String>(list.size)
      val hashes = LongArray(strings.size)
      strings.fill("")
      var count = 0
      loop@ for (variant in list) {
        if (position == variant.position) {
          val text: String? = variant.`object`.toString()
          val hash: Long = StringHash.calc(text)
          for (i in 0..<count) {
            if (hashes[i] == hash) continue@loop
          }
          hashes[count] = hash
          strings[count] = text!!
          count++
        }
      }
      strings.sort()
      count = 0
      for (s in strings) {
        if (s.isNullOrEmpty()) continue
        if (count++ > 0) {
          if (count > MAX_VARIANTS_TO_DISPLAY) {
            sb.append(" ").append(bundle.message("parsing.error.and.ellipsis"))
            break
          }
          else {
            sb.append(", ")
          }
        }
        val c = s.get(0)
        val displayText = if (c == '<' || c.isJavaIdentifierStart()) s else "'$s'"
        sb.append(displayText)
      }
      if (count > 1 && count < MAX_VARIANTS_TO_DISPLAY) {
        val idx = sb.lastIndexOf(", ")
        sb.replace(idx, idx + 1, " " + bundle.message("parsing.error.or"))
      }
      return sb.toString()
    }

    fun clearVariants(frame: Frame?) {
      clearVariants(true, frame?.variantCount ?: 0)
      if (frame != null) frame.lastVariantAt = -1
    }

    fun clearVariants(expected: Boolean, start: Int) {
      val list: MyList<Variant> = if (expected) variants else unexpected
      if (start < 0 || start >= list.size) return
      var i = start
      val len: Int = list.size
      while (i < len) {
        VARIANTS.recycle(list.get(i))
        i++
      }
      list.setSize(start)
    }

    fun typeExtends(child: SyntaxElementType?, parent: SyntaxElementType?): Boolean {
      if (child === parent) return true
      if (extendsSets != null) {
        for (set in extendsSets) {
          if (set.contains(child) && set.contains(parent)) return true
        }
      }
      return false
    }

    companion object {
      fun get(builder: SyntaxTreeBuilder): ErrorState {
        return (builder as Builder).state
      }

      fun initState(state: ErrorState, builder: SyntaxTreeBuilder, root: SyntaxElementType, util: SyntaxGeneratedParserRuntimeBase, extendsSets: Array<Set<SyntaxElementType>>?) {
        state.extendsSets = extendsSets
        state.completionState = if (builder is CompletionVariantProvider) builder.getCompletionState() else null
        state.caseSensitive = util.isLanguageCaseSensitive
        state.braces = util.braces.toTypedArray()
      }
    }
  }

  class Frame {
    var parentFrame: Frame? = null
    var elementType: SyntaxElementType? = null

    var offset: Int = 0
    var position: Int = 0
    var level: Int = 0
    var modifiers: Int = 0
    var name: @NonNls String? = null
    var variantCount: Int = 0
    var errorReportedAt: Int = 0
    var lastVariantAt: Int = 0
    var leftMarker: SyntaxTreeBuilder.Marker? = null

    fun init(
      builder: SyntaxTreeBuilder,
      state: ErrorState,
      level_: Int,
      modifiers_: Int,
      elementType_: SyntaxElementType?,
      name_: String?,
    ): Frame {
      parentFrame = state.currentFrame
      elementType = elementType_

      offset = builder.currentOffset
      position = builder.rawTokenIndex()
      level = level_
      modifiers = modifiers_
      name = name_
      variantCount = state.variants.size
      errorReportedAt = -1
      lastVariantAt = -1

      leftMarker = null
      return this
    }

    override fun toString(): @NonNls String {
      val mod = if (modifiers == _NONE_) "_NONE_, "
      else ((if ((modifiers and _COLLAPSE_) != 0) "_CAN_COLLAPSE_, " else "") +
            (if ((modifiers and _LEFT_) != 0) "_LEFT_, " else "") +
            (if ((modifiers and _LEFT_INNER_) != 0) "_LEFT_INNER_, " else "") +
            (if ((modifiers and _AND_) != 0) "_AND_, " else "") +
            (if ((modifiers and _NOT_) != 0) "_NOT_, " else "") +
            (if ((modifiers and _UPPER_) != 0) "_UPPER_, " else ""))
      return String.format("{%s:%s:%d, %d, %s%s, %s}", offset, position, level, errorReportedAt, mod, elementType, name)
    }
  }

  internal class Variant {
    var position: Int = 0
    var `object`: Any? = null

    fun init(pos: Int, o: Any?): Variant {
      position = pos
      `object` = o
      return this
    }

    override fun toString(): String {
      return "<$position, $`object`>"
    }
  }

  data class BracePair(
    val myLeftBrace: SyntaxElementType? = null,
    val myRightBrace: SyntaxElementType? = null,
    private val myStructural: Boolean = false)
}

private fun CharSequence.crop(length: Int, addEllipses: Boolean): CharSequence {
  if (length >= this.length) return this
  return if (addEllipses) this.substring(0, length) + "..." else this.substring(0, length)
}
